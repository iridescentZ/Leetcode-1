/*
给出n个节点，n条不重复的边，必然形成环，目的就是去除一条边去除这个环
输入的是n条边，输出的是去除的边，[u,v]，u<v
如果出现多条可选择的边，去除最后输入的那条边。
 [[1,2], [2,3], [3,4], [1,4], [1,5]]

这道题目我使用的是dfs的方式进行求解
首先构造了无向图，在dfs每一个节点的边
如果出现两个节点都在之前visited过那么这两个节点就组成了环
但是要求输出最后输入的那条可以去除的边。。。就比较烦还得判断找到的边是不是最后那条。。。复杂度略高
不过也算是一种简单的暴力解法。。。

实际上这道题目最好采用并查集的方式进行。
这类型的问题属于动态连通性问题，一般使用的是一种叫做并查集的数据结构，称为Union-Find
这道题目首先需要对于每个节点建立分组，首先每个节点都是单独的集合
使用一个与节点数等长的数组来表示每一个节点属于哪一个集合
好处在于数组的下标就可以表示每一个节点的序号，每一个元素表示每一个节点属于哪一个集合
初始化数组每一个元素等于其下标，也就是每一个节点属于自己单独的集合。
然后遍历输入的边，我们需要find_root和union操作：
对于构成边的两个节点，我们首先需要找到每个节点属于的集合的根节点
如果这两个节点的根节点是一样的，那么这两个节点属于同一个集合，说明这两个节点构成了环
如果这两个节点不属于一个集合，那么现在就可以将其合并成一个集合，只需要将一个节点的根节点换成另一个节点的根节点即可。
这里得到的这个边就是最后一条输入的可去除边，因为只有当这条边加入的时候才会出现环，这就是最后那条形成环的边，后面不会再有。
 */

//并查集的方式
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        vector<int> parent(2001);
        for(int i=0;i<2001;i++) parent[i]=i;//分组，每组的根节点为i
        for(auto edge : edges){
            int l=findRoot(edge[0],parent),r=findRoot(edge[1],parent);
            if(l == r) //新加入的边形成的环路 是否在同一个分组中
                return edge;
            parent[l] = r; //这里必须是将两个节点的根节点中的一个根接到另一个根下 否则会出现覆盖
        }
        return vector<int> (0, 0);//不存在
    }
    int findRoot(int p,vector<int>& parent){ //寻找p节点对应分组的根节点
        while(p != parent[p])
            p = parent[p];
        return p;
    }
};